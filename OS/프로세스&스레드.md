## 📌 프로그램 vs 프로세스
- **프로그램(Program)**: 저장 장치(HDD, SSD)에 바이너리 형식의 파일로 저장되어, 특정 작업을 수행하는 일련의 명령어 집합
  - **실행 전의 정적인 상태**를 나타냄
 
- **프로세스(Process)**: 저장 장치에 있는 프로그램을 실행함으로써, 해당 프로그램의 바이너리 코드가 메모리에 올라가 실행 가능한 상태가 된 것
  - 메모리에 적재된 프로세스는 운영체제로부터 시스템 자원을 할당 받아 특정 작업을 수행하며, 여러 프로세스가 동시에 실행될 수 있다.
  - **실행 중의 동적인 상태**를 나타냄
 
## 📌 문맥 교환(Context Switching)
- 실행 중인 프로세스에 할당된 CPU를 다른 프로세스로 넘겨주는 과정
- 문맥 교환 횟수가 증가할수록 여러 프로세스들이 동시에 실행되는 것처럼 보이지만, **너무 자주 일어나면 큰 오버헤드가 발생**할 수 있다.

> #### 💭 프로세스 문맥이란?
> 실행 중인 프로세스의 수행 상태에 대한 정보를 의미한다.
>   - 프로그램 카운터(PC)와 각종 레지스터에 저장된 값
>   - 코드, 데이터, 스택, 힙 영역으로 구성된 프로세스만의 독자적인 주소 공간
>   - 프로세스가 현재 실행 중인지, 대기 중인지 등을 나타내는 상태 정보

### 문맥 교환 발생 과정
<img width="473" alt="image" src="https://github.com/user-attachments/assets/1b4e5d2e-ebcc-4157-9e0e-2eae70f2d409">

1. 시스템 콜이나 인터럽트가 발생하면, 현재 실행 중인 프로세스의 문맥을 PCB에 저장한다.
2. 실행 중이던 프로세스의 상태를, 상황에 따라 실행 상태에서 준비, 대기, 종료 상태 중 하나로 변경한다.
   - 타이머 인터럽트로 인해 CPU가 다음 프로세스에 할당될 때 준비 상태로 변경
   - I/O 인터럽트 발생 시 대기 상태로 변경
   - 프로세스의 작업이 마무리되면 종료 상태로 변경
3. 프로세스의 상태에 따라 PCB를 적절한 큐에 넣는다.
   - I/O 작업을 기다려야 하는 경우 **대기 큐**에 저장
   - 다시 실행될 준비가 된 경우 **준비 큐**에 저장
4. 다음에 실행할(CPU를 넘겨줄) 프로세스를 선택하여, 그 프로세스의 상태를 실행 상태로 변경한다.
5. PCB로부터 실행 준비가 완료된 프로세스의 문맥을 복원한 후, 해당 프로세스에 CPU를 할당한다.

### 문맥 교환은 언제 발생할까?
- #### 멀티태스킹 (프로세스 스케줄링)
  운영체제가 여러 프로세스를 동시에 실행하는 멀티태스킹 환경에서, CPU는 하나의 프로세스만을 실행할 수 있다.
  이때 운영체제는 CPU를 여러 프로세스에 분배하기 위해 주기적으로 실행중인 프로세스를 중단하고 다른 프로세스로 전환하는데, 이 과정에서 문맥교환이 발생한다.
        
- #### I/O 인터럽트
  I/O 작업을 수행하는 동안 기존 프로세스는 대기 상태로 전환되고, 운영체제는 다른 프로세스에 CPU를 할당하게 된다.   
  이 과정에서 기존 프로세스의 문맥을 PCB에 저장하고, 새로운 프로세스의 문맥을 PCB로부터 복원한다.

- #### 시스템 콜
  프로세스가 시스템 콜을 통해 커널 모드로 전환되거나, 다른 프로세스로 전환이 필요한 경우 문맥 교환이 일어날 수 있다.

## 📌 프로세스의 메모리 공간
독립적인 하나의 프로세스는 메모리의 사용자 영역 내 여러 영역으로 나뉘어 저장된다.

<img width="447" alt="image" src="https://github.com/user-attachments/assets/7367fbaf-185f-4290-974b-4c9675ea6b43">

> ### 💭 동적 할당 영역 vs 정적 할당 영역
> **프로세스 실행 중에 실시간으로 크기가 변할 수 있는 영역**을 동적 할당 영역이라 한다.   
> 크기가 실시간으로 변하는 동적 할당 영역의 경우, 데이터가 쌓여도 새롭게 할당되는 주소가 겹치지 않게 해야 한다. 따라서 힙 영역은 메모리의 낮은 주소에서 높은 주소로, 스택 영역은 높은 주소에서 낮은 주소로 할당한다.
> 
> 반면에, **프로세스가 시작될 때 크기가 고정되고 실행 중에 크기가 변하지 않는 영역**을 정적 할당 영역이라 한다.   
> 이 영역에 할당된 변수들은 프로그램이 실행될 때 메모리의 특정 위치에 고정되며, 프로그램이 종료될 때까지 그 위치와 크기가 변하지 않습니다.

### 코드 영역
- **기계어로 이루어진 명령어**가 위치하는 영역
- 데이터는 변경될 수 있어도 CPU가 실행할 명령어는 변경될 일이 없기 때문에 **읽기 전용(read-only) 공간**이라 부른다.
- CPU는 코드 영역에 위치한 명령어를 하나씩 가져와서 처리한다.

### 데이터 영역
- 프로세스이 실행되는 동안 사라지지 않고 유지할 데이터(**전역 변수**, **정적 변수**)가 위치하는 영역
- 프로세스의 시작과 동시에 메모리에 할당되고, 프로세스가 종료될 때 메모리에서 소멸된다.
- 데이터 영역은 공간을 효율적으로 활용하기 위해 **초기화된 데이터 영역**과 **BSS(Block Stated Symbol)** 영역으로 구분된다.
  - **초기화된 데이터 영역**: 명시적으로 초기값이 할당된 전역 변수와 정적 변수가 위치하는 영역
  - **BSS 영역**: 초기화되지 않거나, 0이나 null로 초기화된 전역 변수와 정적 변수가 위치하는 영역      
    ```c
    int[10000] arr; // 크기가 10,000인 배열 arr를 선언만 하고 값은 저장되지 않았기에 굳이 arr 크기만큼의 공간을 할당할 필요 X
    ```

### 힙 영역
- **프로그래머에 의해 메모리 공간이 동적으로 할당**되고 해제되는 영역
- 프로그래밍 과정에서 힙 영역에 메모리 공간을 할당했을 때, 그 공간은 언젠가 반드시 반환되어야 한다.   
  만약 메모리 공간을 반환하지 않을 경우 **메모리 누수(memory leak)** 문제가 발생한다.
  - **메모리 누수(memory leak)**: 할당한 공간이 메모리 내에 계속 남아 메모리가 낭비되는 문제
- **가비지 컬렉터**가 있다면 자동으로 공간을 반환해준다.

### 스택 영역
- **지역 변수**와 **매개 변수**가 위치하는 영역
- 함수의 호출과 동시에 메모리에 할당되고, 함수가 종료될 때 메모리에서 소멸됨

## 📌 프로세스 제어블록(Process Control Block, PCB)
- 운영체제가 관리할 프로세스의 정보가 담겨 있는 자료구조
- 프로세스 생성 시 커널 영역에 만들어지고, 프로세스 종료 시 폐기된다.

### 목적
- 빠르게 번갈아 수행되는 프로세스의 실행 순서 관리
- 프로세스에 CPU를 비롯한 하드웨어 자원 배분
 
### 구성 요소
<img width=555 src="https://github.com/user-attachments/assets/b43792fc-8347-4b13-a162-c74ef7ef375e">

- **Process ID (PID)**
  - 특정 프로세스를 식별하기 위한 고유 정보
  - 동일한 프로그램을 2번 실행해서 생성된 각 프로세스의 PID는 모두 다르다.
    
- **레지스터 값**
  - 프로세스가 실행중에 사용했던 레지스터 값
  - 프로세스가 실행 상태로 전환될 때, 이전에 수행했던 작업들을 재개하기 위해 이전까지 사용했던 레지스터 값들을 모두 복원한다.
     
- **프로세스 상태**
  - 현재 프로세스의 상태
  - ex) 현재 프로세스가 I/O 작업을 기다리는 상태인지 or CPU 사용을 기다리는 상태인지 or CPU를 사용하고 있는 상태인지
      
- **CPU 스케줄링 정보**
  - 프로세스가 언제, 어떤 순서로 CPU를 할당 받을지 나타내는 정보
      
- **메모리 관리 정보**
  - 프로세스가 메모리 내 어떤 주소에 저장되어 있는지 나타내는 정보
  - ex) 베이스 레지스터, 한계 레지스터 값
    
  > #### 💭 한계 레지스터(Limit Register)란?
  > 프로세스가 접근할 수 있는 메모리 주소 범위의 상한 값을 저장하는 레지스터
  > ex) 베이스 레지스터 값 = 1000, 한계 레지스터 값 = 500인 경우 해당 프로세스는 1000~1500(1000+500)의 주소 범위 내에서만 메모리 접근 가능하다.

- **사용한 파일과 I/O 장치 목록**
  - 프로세스가 어떤 파일들을 열었는지 나타내는 정보
  - 프로세스에 어떤 I/O 장치가 할당되었는지 나타내는 정보

## 📌 프로세스 상태 변화 과정
<img width=600 src="https://github.com/user-attachments/assets/877d2edf-77e2-4e24-8a43-07a470321ba6">

- #### 생성 상태 (New)
  - 프로세스가 생성되어 PCB를 할당받은 상태
  - 곧바로 준비 상태로 전환되어 CPU 할당을 기다린다.
- #### 준비 상태 (Ready)
  - 당장 CPU를 할당 받아 실행 가능하지만, 아직 차례가 아니기에 기다리는 상태
  - 차례가 되면 실행 상태로 전환되며, 이 과정을 **디스패치**(**Dispatch**)라고 한다.
- #### 실행 상태 (Running)
  - CPU를 할당 받아 실행중인 상태
  - 할당된 일정 시간 동안만 CPU를 사용할 수 있다.
  - **타이머 인터럽트** 발생 시(할당된 시간 모두 사용 시) 준비 상태로 전환된다.
  - **I/O 인터럽트** 발생 시 대기 상태로 전환된다.
- #### 대기 상태 (Blocked)
  - I/O 작업을 기다리는 상태
  - I/O 작업 완료 시 준비 상태로 전환된다.
- #### 종료 상태 (Terminated)
  - 프로세스가 종료중인 상태
  - 프로세스 종료 시 운영체제는 프로세스가 사용한 메모리와 PCB를 정리한다.

## 📌 멀티 프로세스
- 여러 독립적인 프로세스를 동시에 실행하는 기술
- 각 프로세스는 **독립적으로 실행**된다.
  - 하나의 프로세스에 문제가 발생해도 다른 프로세스에 영향을 미치지 않는다.
  - 별도의 메모리 공간과 자원을 사용하므로, 메모리와 CPU 자원의 소비량이 증가한다.
 
## 📌 프로세스끼리 협력하는 방법
일반적으로 하나의 프로세스는 다른 프로세스의 수행에 직접적인 영향을 미칠 수 없다.    
하지만 자원 효율성이나 처리 속도를 높이기 위해서는 프로세스 간의 협력이 필요하다.   
따라서 운영체제는 프로세스 간의 협력 메커니즘을 제공해 하나의 프로세스가 다른 프로세스의 수행에 영향을 미칠 수 있게 한다.

### IPC(Inter-Process Communication)
- 서로 다른 프로세스들 간의 통신과 동기화를 이루기 위한 협력 메커니즘
- IPC의 대표적인 방법으로 **메시지 전달 방식**과 **공유 메모리 방식**이 존재한다.

### 메시지 전달 방식

<img width=600 src="https://github.com/user-attachments/assets/8ee85164-d1bc-4d3c-9fd1-3e441156a495">

- 프로세스 간에 데이터를 주고받기 위해 구조화된 메시지를 사용하여 통신하는 방식
- 메시지를 전달할 때마다 커널이 개입하기 때문에, 다음과 같은 장단점이 존재한다.
    - **동기화 문제가 발생하지 않는다**.
    - **높은 커널 의존성**을 가지게 되며, **동작 속도가 느려진다.**
- **비동기적인 통신**이 가능하다. 즉, 메시지를 보내는 프로세스는 메시지를 보낸 후 즉시 자신의 작업을 계속할 수 있고, 받는 프로세스는 나중에 메시지를 받을 수 있다.
- 직접 통신과 간접 통신으로 구분된다.
    - **직접 통신**
        - 시스템 콜에 통신하려는 프로세스의 식별자(PID)를 명시하여, 메시지를 직접 전달하는 방식
            - `send(p, message)`: 프로세스 p에게 메세지 전송
            - `receive(Q, message)`: 프로세스 Q로부터 메세지 수신
        - 송신 프로세스가 시스템 콜을 호출하면, 커널은 시스템 콜에 명시된 수신 프로세스에게 메시지를 전달한다.
    - **간접 통신**
        - 메시지가 중간 매개체를 통해 전달되는 방식
        - 송신 프로세스는 메시지를 메시지 큐에 전달하고, 수신 프로세스는 그 큐에서 메시지를 가져온다.
        - 중간 매개체로는 메시지 큐, 파이프, 소켓 등을 사용한다.
        - 각 매개체에는 고유 ID가 있으며, 매개체를 공유하는 프로세스들만 서로 통신할 수 있다.
        - 하나의 매개체가 여러 프로세스들에게 할당될 수 있고, 각 프로세스의 쌍은 여러 매개체를 공유할 수 있다.
        - `send(A, message)`: A라는 매개체에 메세지 전송
        - `receive(A, message)`: A라는 매개체로부터 메세지 수신

### 공유 메모리 방식
<img width=400 src="https://github.com/user-attachments/assets/ea89e183-a2ea-477a-b7bf-fd397113ec05">

- 프로세스들이 주소 공간의 일부를 공유하는 방식
- 프로세스가 시스템 콜을 통해 커널에 공유 메모리 할당을 요청하면, 커널은 해당 프로세스에 공유 메모리 공간을 할당한다. 이후 어떤 프로세스건 해당 메모리 공간에 접근할 수 있다.
- 프로세스는 커널의 개입 없이 바로 공유 메모리에 접근할 수 있기 때문에 **동작 속도가 빠르다**.
- 프로세스 동기화가 적절하게 이루어지지 않을 경우 **데이터 일관성 문제가 발생**할 수 있다.

## 📌 fork 명령어
- 현재 실행 중인 프로세스의 복사본을 만드는 시스템 콜
- 복사본을 만들 대상 프로세스를 **부모 프로세스**라고 하며, fork를 통해 생성된 복사본을 **자식 프로세스**라고 한다.
- 자식 프로세스는 부모 프로세스의 자원들을 초기 상태 그대로 복사해 시작하지만, 이후에는 이 자원들을 독립적으로 사용한다.   
  이로 인해 프로세스를 많이 생성할수록 자원 소모량이 증가한다.

### 동작 원리
1. `fork`를 호출하면 현재 실행 중인 프로세스의 복사본이 생성되며, 이 복사본은 부모 프로세스의 자원들을 그대로 복사하여 독립적으로 가진다.
2. `fork` 호출이 성공하면, 부모 프로세스는 자식 프로세스의 PID를 반환받고 자식 프로세스는 0을 반환 받는다.   
  (반환값을 통해 프로세스가 자신이 부모인지 자식인지 구분 가능)
3. 만약 `fork` 호출이 실패하면, 부모 프로세스는 1을 반환받고 자식 프로세스는 생성되지 않는다.

### fork 명령어를 어디에 활용할 수 있을까?
`fork`는 여러 프로세스가 동시에 다른 작업을 수행할 수 있도록 하며, **멀티 프로세스** 환경에서 유용하다.

---

## 📌 스레드(Thread)란?
- **프로세스 내에서 실행되는 흐름의 단위**
- 하나의 프로세스는 내부에 여러 개의 스레드를 가질 수 있으며, 이들은 **서로의 자원을 공유**한다.
  - 스레드 간 효율적인 통신 가능
  - 빠른 스레드 생성 가능
- 여러 스레드가 공유 자원에 동시 접근할 경우 **경쟁 상태**가 발생할 수 있다.
- 병렬 처리를 통해 **응답 속도**를 높이고, **동시성**을 구현할 수 있음

## 📌 스레드의 메모리 공간
<img width=500 src="https://github.com/user-attachments/assets/0682dd92-14fb-441f-94a7-5abcfdf78dc0">

- 각각의 스레드는 별도의 레지스터와 스택을 할당받고, **프로세스 내의 나머지 영역(코드, 데이터, 힙)은 서로 공유**한다.
  
  > #### 💭 왜 레지스터와 스택은 별도로 관리할까?
  > - 스레드는 일종의 함수로 구현되므로, 데이터를 다루고 관리하기 위해 별도의 스택을 가진다.
  > - 스레드는 실행되는 동안 CPU의 레지스터를 사용하며, 문맥 교환이 발생할 때 현재 스레드의 레지스터 값을 별도로 저장해야 한다.
  
- 하나의 스레드가 공유 자원을 변경하면, 같은 프로세스에 있는 다른 스레드도 그 변경 사항을 즉시 확인할 수 있다.

## 📌 스레드 제어 블록(Thread Control Block, TCB)
<img width=600 src="https://github.com/user-attachments/assets/cc9e49d4-9aae-47c4-a9d4-16dfe1396336">

- 운영 체제가 각 스레드를 관리하기 위해 사용하는 데이터 구조
- 각 스레드의 상태 정보를 저장하고, 스레드 간의 문맥 교환이 일어날 때 필요한 데이터를 보관하는 역할을 수행한다.
- 각 스레드는 별도의 TCB를 가지고 있다.
- TCB에는 다음과 같은 정보들이 저장된다.
  - 스레드 ID
  - 스레드 상태 정보
  - 레지스터 값(PC, SP)
  - 스케줄링 정보(CPU 시간, 우선순위)

## 🚧 사용자 수준 스레드 vs 커널 수준 스레드

## 📌 멀티 스레드
### 멀티 스레드 프로그래밍
- 하나의 프로세스 내에서 여러 개의 스레드를 동시에 실행하여 작업을 병렬로 처리하는 기술
- 같은 프로세스 내의 스레드들은 **프로세스 내 대부분의 자원을 공유**한다.
- 스레드는 프로세스에 비해 생성 및 종료 시 오버헤드가 적고, 문맥 전환이 더 빠르다.
    - 

### 장점
- 스레드는 같은 프로세스 내에서 동작하므로, **문맥 교환이 빠르고 효율적**이다.
  - 스레드 간 문맥 전환 시 변경해야 하는 자원은 CPU 레지스터와 스택 포인터 뿐이므로 속도가 빠르다.
  - 스레드는 프로세스와 달리 많은 자원을 공유하므로, 문맥 교환이 일어났을 경우 새롭게 교환되는 스레드가 이전의 캐시 데이터에 대한 이점을 볼 수 있어 효율적이다.
    > 프로세스 간에는 공유하는 자원이 없기 때문에, 프로세스 간 문맥 교환이 일어났을 경우 이전에 캐시에 저장되어 있던 데이터는 의미가 없어진다.
- 같은 프로세스 내에서 동작하는 여러 스레드는 메모리 공간을 공유하므로, **메모리를 효율적으로 사용**한다.
- 멀티 스레드를 사용하면 작업이 병렬로 처리되므로, **동시성 및 응답성이 향상**된다.
  - ex) 웹 서버는 각 클라이언트 요청을 별도의 스레드로 처리하여 동시성 성능을 높일 수 있다.
  - ex) GUI 애플리케이션에서 사용자가 버튼을 클릭했을 때, 백그라운드에서 데이터 처리를 수행하는 스레드가 있더라도 메인 스레드는 여전히 사용자와 상호작용할 수 있다.
- 새로운 프로세스를 생성하는 것보다 스레드를 생성하는 것이 자원적으로 **더 적은 비용**이 든다.
  - 프로세스 fork는 모든 정보를 자식에게 복사하는 반면, 스레드는 프로세스의 많은 부분을 공유하기 때문에 일부분만 복사해서 생성할 수 있다.
- 프로세스 간 통신은 커널이 개입되어야 하지만, 같은 프로세스 내의 스레드들은 메모리와 파일을 공유하기 때문에 **커널 호출 없이 효율적으로 통신**할 수 있다.

### 단점
- 여러 스레드가 동시에 자원을 공유하기 때문에, 동기화와 관련된 복잡한 문제들(경쟁 상태, 데드락)이 발생할 수 있다.
- 동기화 문제와 관련된 코드가 추가되면서 유지보수가 어려워진다.
- 스레드 간의 비동기적 실행 때문에, 동일한 코드에서도 실행 순서에 따라 다른 결과가 나올 수 있어 디버깅이 매우 어렵다.

### 멀티 프로세스 대신 멀티 스레드를 사용하는 이유
- #### 빠르고 효율적인 문맥 교환
  스레드는 같은 주소 공간을 공유하기 때문에, 주소 공간을 전환할 필요가 없고 CPU 레지스터와 스택 포인터만 변경하면 된다.   
  또한, 스레드는 프로세스와 달리 많은 자원을 공유하므로, 문맥 교환이 일어났을 경우 새롭게 교환되는 스레드가 이전의 캐시 데이터에 대한 이점을 볼 수 있어 효율적이다.   
  반면, 프로세스 간에는 공유하는 자원이 없기 때문에, 프로세스 간 문맥 교환이 일어났을 경우 이전에 캐시에 저장되어 있던 데이터는 의미가 없어진다.
- #### 효율적인 메모리 사용
  멀티 스레드는 프로세스의 메모리 공간을 공유하므로, 스레드 간의 데이터 교환이 매우 빠르고 효율적으로 이루어진다.   
  반면, 멀티 프로세스는 독립적인 메모리 공간을 가지고 있기 때문에, 데이터를 교환하려면 비용이 많이 드는 IPC 메커니즘을 사용해야 한다.
- #### 오버헤드가 적은 스레드 생성 및 종료
  프로세스 fork는 모든 정보를 자식에게 복사하는 반면, 스레드는 프로세스의 많은 부분을 공유하기 때문에 일부분만 복사해서 생성할 수 있다.

### 멀티 스레드 프로그래밍에서 주의할 점
- 여러 스레드가 공유 자원을 동시에 접근할 때 데이터 불일치 문제가 발생할 수 있으므로, **동기화 메커니즘**(뮤텍스, 세마포어)을 사용해야 한다.
- 잘못된 동기화로 인해 두 개 이상의 스레드가 서로 다른 자원의 락을 기다리면서 **교착 상태(deadlock)** 문제가 발생할 수 있다.
- 스레드가 증가함에 따라 **리소스 관리가 복잡**해질 수 있으며, 시스템의 한계를 넘어서는 스레드 생성은 성능 저하를 초래할 수 있다.   
  리소스는 한정적인데, 이를 많은 스레드가 동시에 공유하게 되면 시스템 병목을 유발하고, 결국 시스템 성능이 저하된다.

## 🚧 Thread-Safe하다는 의미와 그렇게 설계하는 방법
