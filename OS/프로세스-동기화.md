## 📌 병행성(동시성) vs 병렬성
<img width=400 src="https://github.com/user-attachments/assets/eb19f9ce-00fb-49a9-bd59-1d2082527b02">

### 병행성(Concurrency)
- **여러 작업이 동시에 실행되는 것처럼 보이는 상태** (논리적인 개념)
- **싱글 코어에서** 다수의 프로세스들을 빠른 속도로 번갈아 가며 실행하기 때문에, 사용자 입장에서는 동시 처리되는 것처럼 보인다.
- 핵심 목표는  **CPU 유휴 시간을 최소화**하고, 이를 통해 **자원 효율성을 극대화**하는 것이다.
- 실제로 작업이 동시에 실행되는 것이 아니라, 시분할 방식으로 이루어지기 때문에 **연산이 많은 작업에서 성능의 한계가 존재**한다.
- 여러 프로세스들이 자원을 공유하기 때문에 **경쟁 상태나 데드락이 발생**할 수 있다.   
  이러한 동기화 문제를 해결하기 위해 뮤텍스, 세마포어 등 다양한 메커니즘을 사용한다.
- 예시
  - 웹 서버는 여러 클라이언트 요청을 동시에 처리하기 위해, **멀티스레딩** 기법을 이용한다.
  - 대기 시간이 긴 작업(I/O, 네트워크 통신 등)을 **비동기**로 처리하여 프로그램의 반응성을 높인다.

### 병렬성(Parallelism)
- **여러 작업이 실제로 동시에 실행되는 것** (물리적인 개념)
- **멀티 코어 또는 멀티 프로세서에서** 다수의 프로세스들을 독립적으로 실행한다.
- 실제로 여러 작업을 동시에 처리할 수 있기 때문에, **연산이 많은 작업에서 큰 성능 향상을 제공**한다.
- 병행성 시스템에 비해 **설계와 구현이 복잡하며, 동기화 비용도 크다.**
- 주로 **대규모 데이터 처리**나 **복잡한 계산 작업**에서 사용된다.

## 📌 프로세스 동기화
- 여러 프로세스가 공유 자원에 동시 접근할 때, 일정한 순서나 규칙에 따라 동작하도록 조율하는 기법
  - **공유 자원**: 여러 프로세스가 공동으로 이용하는 자원(변수, 메모리, 파일 등)
- 주요 동기화 메커니즘에는 뮤텍스, 세마포어, 모니터, 락이 있다.

### 왜 필요할까?
여러 프로세스가 공유 자원(메모리, 파일, 데이터베이스)에 동시 접근하여 읽기/쓰기 작업을 수행할 때, 동기화가 제대로 이루어지지 않으면 경쟁 상태(데이터 불일치), 데드락 등의 문제가 발생할 수 있다.

<img width=500 src="https://github.com/user-attachments/assets/13beffaf-3640-4572-96af-b3ba15b15c91">

예를 들어, 프로세스 동기화가 이루어지지 않은 상태에서 두 프로세스가 동시에 데이터 쓰기 작업을 수행하면, 해당 데이터가 손상될 수 있다.
따라서 프로세스의 실행 순서를 조율하여 데이터 무결성을 보장하기 위해 동기화가 필요하다.

## 📌 임계 구역(Critical Section)
<img width=500 src="https://github.com/user-attachments/assets/d0792f0d-ba6a-403c-87aa-c9210e19e6b2">

- 여러 프로세스의 공유 자원 접근 순서에 따라 실행 결과가 달라지는 코드 영역
- 잘못된 실행으로 인해 임계 구역의 코드를 동시에 실행할 경우 동기화 문제가 발생한다.

### 프로세스의 일반적인 구조
```c
while (true) {
  entry section // 진입 구역
    critical section // 임계 구역
  exit section // 퇴출
    remainder section // 코드의 나머지 구역
}
```

1. **진입 구역(Entry Section)**: 임계 구역에 진입하기 전에 다른 프로세스가 임계 구역을 사용하고 있는지 확인하고, 사용할 수 있는 권한을 얻는 단계
2. **임계 구역(Critical Section)**: 공유 자원에 접근하여 작업을 수행하는 단계
3. **퇴출 구역(Exit Section)**: 임계 구역에서의 작업이 완료된 후, 해당 프로세스가 임계 구역을 떠나며 다른 프로세스가 임계 구역에 진입할 수 있도록 준비하는 단계

### 임계 구역 문제를 해결하기 위한 동기화의 필수 조건
- **상호 배제(Mutual exclusion)**: 한 프로세스가 임계 구역에 진입해 있는 동안, 다른 프로세스는 임계 구역에 진입할 수 없다.
- **진행(Progress)**: 임계 구역에 어떤 프로세스도 진입하지 않았다면, 임계 구역에 진입하려는 프로세스 중 하나는 임계 구역에 진입할 수 있어야 한다.
- **유한 대기(Bounded waiting)**: 특정 프로세스가 임계 구역에 진입하기 위해 대기하는 시간은 유한해야 한다. 이를 통해 기아 상태를 방지할 수 있다.

## 📌 경쟁 상태(Race Condition)
- 여러 프로세스들이 공유 자원에 동시 접근하여, 해당 자원을 서로 사용하기 위해 경쟁하는 상태
- 경쟁 상태로 인해 예기치 않은 동작이나 버그가 발생할 수 있으며, 이로 인해 데이터의 일관성이 깨질 수도 있다.
- 경쟁 상태를 막기 위해서는, 뮤텍스나 세마포어 같은 동기화 메커니즘을 사용하여 공유 자원에 대한 동시 접근을 적절히 제어해야 한다.

### 경쟁 상태가 발생하는 상황
- **인터럽트가 발생하는 경우**   
  - 어떤 프로세스가 커널 모드에서 실행되는 동안 인터럽트가 발생하면, 현재 실행 중이던 프로세스가 중단되고 인터럽트 서비스 루틴(ISR)이 실행된다. ISR 역시 커널 코드이므로, 이 과정에서 커널의 공유 자원에 접근하면 경쟁 상태가 발생할 수 있다.   
  - 해결 방법: 인터럽트 처리 중에 동기화를 적용하거나, 인터럽트 발생 시점에 특정 자원의 접근을 차단하여 문제가 발생하지 않도록 해야 한다.
    
- **문맥 교환이 발생하는 경우**   
  - 프로세스 A가 시스템 콜을 통해 커널 모드로 진입하여 커널의 공유 자원을 처리하는 중에 문맥 교환이 발생하면, 프로세스 B로 CPU 제어권이 넘어간다. 이때 프로세스 B도 동일한 시스템 콜을 통해 동일한 공유 자원에 접근하면 경쟁 상태가 발생할 수 있다.   
  - 해결 방법: 커널 모드에서 실행 중일 때 문맥 교환이 발생하지 않도록 하거나, 커널 모드에서의 공유 자원 접근 시 동기화 메커니즘을 사용하여 경쟁 상태를 방지해야 한다.
 
## 📌 상호 배제(Mutual Exclusion)
- 공유가 불가능한 자원의 동시 사용을 피하기 위해 사용하는 알고리즘
- 병행 시스템에서 단 하나의 프로세스만이 임계 구역에 접근할 수 있도록 하는 것을 의미한다.
- 예를들어, 어떤 프로세스가 순차적으로 데이터를 읽는 작업을 하는 도중에 다른 프로세스가 해당 데이터를 변경해버리면 읽어오는 값이 달라진다. 따라서 상호배제를 통한 동기화 작업을 해줘야한다.

### 상호 배제 구현 방법
- #### Dekker’s algorithm (Peterson’s algorithm)
  ```c
    // entry section
    void enter_section() {
        flag[i] = true; // 프로세스 i의 임계구역 진입 준비 완료
        turn = j; // 프로세스 j에게 임계구역 진입 순번 부여
    
        // 프로세스 j가 임계 구역에 진입하기를 원한다면 j가 먼저 진입하는 것을 보장하고 기다림
        while (flag[j] && turn == j) ; // busy wait!!!
    }

    // exit section
    void exit_section() {
        flag[i] = false; // 임계구역을 벗어나면서 플래그 off
    }
  ```
  - 고전적인 소프트웨어 기반으로 상호 배제를 구현하는 방법
  - 플래그(`flag`)와 순번(`turn`) 변수를 이용하여 오직 하나의 프로세스만이 임계 구역에 진입하도록 조정하는 알고리즘

- #### TestAndSet(TAS) instruction
  ```c
  void enter_section() {
      while (test_and_set(&lock)) ;
  
      // critical section
  
      lock = false;
  
      // remainder section
  }

  boolean test_and_set(boolean *target) {
      boolean temp = *target
      *target = true;
      return temp;
  }
  ```
  - 하드웨어 수준에서 상호 배제를 구현하는 방법
  - TAS(`test_and_set`) 연산은 문맥 교환 없이 원자적(atomic)으로 수행된다.   
    즉, 특정 메모리 위치의 값을 읽고 새로운 값을 설정하는 작업을 한 번에 수행한다.
  - 원자적인 연산을 통해 임계 구역에 대한 접근 권한을 한 프로세스에만 부여할 수 있다.

- #### OS supported SW solution
  - Spinlock
  - Semaphore

- #### Language-Level solution
  - Monitor

## 📌 뮤텍스 락(Mutual Exclusion Lock; Mutex Lock)
```c
do {
    acquire(); // lock이 걸려 있는지 확인하고, 걸려 있지 않다면 임계 구역에 진입하면서 lock 획득

    // critical section

    release(); // 작업을 마무리한 뒤 임계 구역을 벗어나면서 lock 해제

    // remainder section
} while (true);
```
- 여러 프로세스의 공유 자원 동시 접근을 제한하기 위해 lock을 사용하는 동기화 기법
- 오직 하나의 프로세스만이 lock을 획득할 수 있으며, 그 프로세스만이 lock을 해제할 수 있다.
- 잠금 메커니즘 측면에서 spin lock과 동일하지만, 임계 구역 진입 권한을 획득할 때까지 busy waiting 상태에 머무르지 않고 대기 상태에 접어든다.
- lock을 소유하고 있던 프로세스가 임계 구역을 벗어나면, 운영체제 스케줄러에 의해 대기 상태에 있던 프로세스가 wakeup된다.

 ## 📌 세마포어(Semaphore)
- 프로세스 동기화 기능을 제공하는 추상 자료형
- 세마포어 `S`는 정수형 값을 가지며, 자원의 개수를 나타낸다.
- 공용 변수 `S`는 `P`와 `V`라는 원자적(atomical) 연산에 의해서만 접근 가능하다.
  - **P 연산(Wait)**: 세마포어 값을 감소시키는 연산
    - 프로세스나 스레드가 자원을 요청할 때, 즉 임계 구역에 들어가기 전에 수행된다.
    - 만약 세마포어 값이 0이하라면, 자원 사용이 불가능하므로 대기한다.
    - 네덜란드어 *proberen*에서 따온 `P`로 표기
  - **V 연산(Signal)**: 세마포어 값을 증가시키는 연산
    - 자원의 사용을 마친 후 자원을 해제할 때, 즉 임계 구역에서 나오는 시점에 수행된다.
    - 임계 구역 앞에서 대기하는 프로세스가 있다면 ‘진입 가능’ 신호를 보낸다.
    - 네덜란드어 *verhogen*에서 따온 `V`로 표기

### 구현 방식
- #### Busy wating 방식 (Spin-Lock)
  ```c
  void P(S) {
      while (S <= 0) { // 남은 공유 자원이 없을 경우, 얻을 수 있을 때까지 반복해서 확인
          ; // busy waiting
      }
      S--; // S가 양수인 경우 임계 구역에 진입하면서 공유 자원 1개 획득
  }
    
  void V(S) {
      S++; // 임계 구역을 벗어나면서 공유 자원 반납
  }
  ```  
  - 원하는 자원을 얻을 수 있을 때까지 반복적으로 확인하는 과정에서 CPU 자원이 소비된다. 이로 인해 자원이 낭비된다는 
 
- #### Block and Wake up 방식 (Sleep-Lock)    
  ```java
  void P(S) {
      S--; // 임계 구역에 진입하면서 공유 자원 1개 획득
      if (S < 0) { // 남은 공유 자원이 없을 경우
          block(); // 현재 프로세스를 대기 큐에 저장하면서 대기 상태로 변경
      }
  }
  
  void V(S) {
      S++; // 임계 구역을 벗어나면서 공유 자원 반납
    	if (S <= 0) { // 남은 공유의 개수가 0 이하일 경우
          wakeup(); // 대기 큐에서 프로세스를 꺼내 준비 상태로 변경
      }
  }
  ```
  - `block()`과 `wakeup()` ⇒ 프로세스를 일시 중지 or 재실행시키는 운영체제의 기본적인 시스템 콜
    > 세마포어 `S`의 값이 0보다 크다면, 이는 자원이 남아 있다는 의미이므로 대기 중인 프로세스가 없을 가능성이 크다. 따라서 대기 중인 프로세스를 깨울 필요가 없다.   
    > 반대로 `S`의 값이 0보다 작거나 같다면, 이는 남아 있는 자원이 없다는 의미이므로 대기 중인 프로세스가 있을 가능성이 크다. 따라서 대기 중인 프로세스를 깨워야 한다.

- 임계 구역 길이가 매우 짧은 경우가 아니라면, 일반적으로 Block and Wake up 방식의 성능이 더 좋다.

### 종류
- **이진 세마포어(Binary semaphore)**
  - `S` == 0 또는 1의 값만 가질 수 있는 세마포어
  - 상호 배제를 위한 동기화 기법으로서 뮤텍스 락과 유사하다.
  - 이진 세마포어 값에 따른 상태 구분
    - 1 ⇒ 공유 자원 접근 가능
    - 0 ⇒ 공유 자원 접근 불가능
- **카운팅 세마포어(Counting semaphore)**
  - `S` == 공유 자원의 수를 나타내는 (양의 정수값을 가지는) 세마포어   
    ex) `S`의 값이 3인 경우, 남은 공유 자원의 개수가 3개라는 의미이므로 최대 3개의 프로세스가 동시에 공유 자원에 접근 가능

## 📌 뮤텍스 vs 세마포어
### 접근 제어 방식
- 뮤텍스는 잠금(lock) 메커니즘을 사용하여 오직 하나의 프로세스만이 특정 자원에 접근할 수 있도록 보장한다.
- 세마포어는 공유 변수의 값에 따라 여러 프로세스가 동시에 자원에 접근할 수 있다.

### 소유권
- 뮤텍스는 특정 프로세스가 lock을 획득하면 **그 프로세스만이 lock을 해제**할 수 있다.
- 세마포어는 소유권 개념이 없기 때문에, **어느 프로세스든 세마포어 값을 변경**할 수 있다.    
  이는 더 유연하지만, 잘못된 해제 또는 중복 해제 등의 실수가 발생할 가능성이 높다.

### 사용 목적
- 뮤텍스는 주로 임계 구역에서 데이터의 일관성을 유지하기 위해 사용된다.
  - 문제: 여러 사용자가 동시에 같은 상품을 주문할 때, 재고 감소 작업이 동시에 발생하여 데이터 불일치가 발생할 수 있다.
  - 해결책: 재고 감소 작업을 임계 구역으로 설정하고, 뮤텍스 락을 사용하여 한 번에 하나의 스레드만 이 작업을 수행하도록 한다. 이를 통해 여러 사용자가 동시에 재고를 감소시키려고 하더라도, 다른 스레드가 lock을 획득한 상태일 때 다른 스레드의 접근을 차단하여 데이터의 일관성을 유지할 수 있다.

- 세마포어는 여러 개의 자원을 관리하거나, 작업 간의 실행 순서를 동기화하기 위해 사용된다.
  - 문제: 데이터베이스 연결이 한정된 서버에서 동시에 너무 많은 요청이 들어오면, 데이터베이스에 과부하가 발생할 수 있다. 이로 인해 서버 성능이 저하되거나 요청이 실패할 수 있다.
  - 해결책: 세마포어를 사용하여 데이터베이스 연결 수를 제한할 수 있다. 세마포어를 통해 최대 연결 수를 설정하고, 새로운 요청이 들어올 때마다 세마포어를 통해 현재 사용 가능한 연결 수를 확인한다. 연결 수가 허용된 범위 내에 있을 경우에만 데이터베이스에 접근하도록 하여 서버 리소스를 효과적으로 관리하고 성능을 유지할 수 있다.
 
## 🚧 모니터(Monitor)

## 📌 교착 상태(Deadlock)
- 둘 이상의 프로세스들이 서로가 가진 자원을 기다리며 무한정 대기하는 상태
- 예시
  - 게임 프로세스는 자원 A를 점유한 채, 자원 B를 사용할 수 있을 때까지 대기
  - 웹 브라우저 프로세스는 자원 B를 점유한 채, 자원 A를 사용할 수 있을 때까지 대기
  - 두 프로세스는 서로 상대방이 점유한 자원을 기다리가다가 결국 실행 X

### 교착 상태 발생 조건 4가지
아래 4가지 조건에 모두 해당할 경우 데드락이 발생한다.

- **상호배제(Mutual exclusion)**
  - 하나의 프로세스가 사용 중인 자원을 다른 프로세스가 사용할 수 없는 경우
- **점유와 대기(Hold and wait)**
  - 프로세스가 자원을 할당 받은 상태에서 다른 자원을 요청하며 기다리는 경우
- **비선점(Non-preemption)**
  - 어떤 프로세스도 다른 프로세스의 자원을 강제로 빼앗을 수 없는 경우
- **원형 대기(Circular wait)**
  - 자원을 기다리는 프로세스간에 사이클이 형성되는 경우
 
### 자원 할당 그래프
<img width=500 src="https://github.com/user-attachments/assets/318d7045-acd0-4e7a-93df-662357b08f1d">

- 프로세스의 자원 할당 상태를 표현하는 그래프

- #### 표현 방법
  - 프로세스는 원으로, 자원의 종류는 사각형으로 표현한다.
  - 사용 가능한 자원의 개수는 사각형 내에 점으로 표현한다.
  - 프로세스가 어떤 자원을 할당 받은 상태는 ‘자원 → 프로세스’ 선으로 표현한다.
  - 프로세스가 어떤 자원을 요청하는 상태는 ‘프로세스 → 자원’ 선으로 표현한다.

- #### 자원 할당 그래프에 사이클이 존재하는 경우
  - 자원의 개수가 하나 뿐이라면 데드락 상태를 의미한다.
  - 자원의 개수가 둘 이상이라면 데드락일 수도, 아닐 수도 있다.

## 📌 교착 상태를 막는 다양한 방법
### 교착 상태 예방
- 데드락 발생 조건 중 어느 하나라도 해당하지 않도록 예방하는 방식

- #### 상호배제(Mutual exclusion) 조건 위반
  - 모든 자원을 공유 가능하게 한다.
  - 다수의 프로세스들이 공유 자원을 사용한다면 데이터 불일치 문제가 발생하기 때문에 **현실적으로 위반할 수 없다.**

- #### 점유와 대기(Hold and wait) 조건 위반
  - 프로세스가 자원을 할당 받은 상태에서 다른 자원을 요청하지 못하게 한다.
  - 프로세스 시작 시 모든 필요한 자원을 할당 받게 하거나, 프로세스가 다른 자원을 요청할 때 할당 받은 자원을 모두 해제한다.
  - 당장 자원이 필요해도 기다릴 수 밖에 없는 프로세스나, 사용되지 않으면서 오랫동안 프로세스에 할당되는 자원이 많을수록 **자원 활용률이 감소**한다.

- #### 비선점(Non-preemption) 조건 위반
  - 프로세스가 이용 중인 자원을 강제로 빼앗을 수 있게 한다.
  - **모든 자원이 선점 가능할 수 없다.**    
    ex) 한 번에 하나의 프로세스만 이용 가능한 프린터의 경우, 한 프로세스가 프린터를 이용하는 도중에 다른 프로세스가 프린터 자원을 빼앗아 사용하기란 어렵다.
        
- #### 원형 대기(Circular wait) 조건 위반
  - 모든 자원에 할당 순서를 정하여, 그 순서대로만 자원을 할당한다.   
    ex) 5번 자원을 할당 받은 프로세스는 5보다 작은 1번 자원을 할당 받을 수 없다.      
  - 모든 컴퓨터 시스템 내에 존재하는 **수많은 자원에 할당 순서를 정하기는 어렵다.**
  - 각 자원에 어떤 순서를 정하는지에 따라 **특정 자원의 활용률이 감소한다.**

결국 교착 상태 예방은 결국 부작용이 존재할 수 밖에 없다.

### 교착 상태 회피
- 데드락이 발생하지 않을 정도로만(항시 안전 상태를 유지하도록) 자원을 할당하는 방식
- 어떤 프로세스가 자원을 요청했을 때, 그 프로세스가 요청할 수 있는 자원의 최대 요구량보다 현재 가용 자원량이 클 경우에만 자원을 할당한다.

- #### 안전 상태
  - 안전 순서열대로 프로세스들에 자원을 배분하여 데드락이 발생하지 않는 상태
    - **안전 순서열**: 교착 상태 없이 안전하게 프로세스들에 자원을 할당할 수 있는 순서
  - 예시

    <img width="526" alt="image" src="https://github.com/user-attachments/assets/bbf686ee-a30b-4cd0-b2c1-9c9b7b4ba891">

    `P2 → P1 → P3`이라는 안전 순서열대로 자원을 배분하면 데드락이 발생하지 않는다.

- #### 불안전 상태
    - 안전 순서열이 없어 데드락이 발생할 수 있는 상태
    - 예시   

      <img width="469" alt="image" src="https://github.com/user-attachments/assets/08ceefc4-0c43-4763-a613-a42916c232e8">

      P2가 정상 종료된다고 해도, 이후 반환된 자원으로는 P1과 P3의 요구량을 충족시킬 수 없기 때문에 데드락이 발생한다.

### 교착 상태 회피 알고리즘
- #### 변형된 자원 할당 그래프 알고리즘
  <img width=500 src="https://github.com/user-attachments/assets/2419d704-3e1d-4735-8578-4c2eb9f94504">

  - 각 자원의 **단위 자원이 하나밖에 없을 때 사용**하는 알고리즘
  - 프로세스가 특정 자원을 요청하게 될 것임을 의미하는 **선언 간선(점선)을 추가**한다.
  - 운영체제의 승인으로 인해 자원을 실제로 요청하게 되면 선언 간선을 요구 간선으로 변경한다.
  - 변경된 요구 간선을 할당 간선으로 변경해도 사이클이 생기지 않는 경우에만 자원을 할당한다.

    <img width=500 src="https://github.com/user-attachments/assets/57b014c7-1d91-41fd-ac7c-2c4178ec66f8">

- #### 은행원 알고리즘
  - 각 자원의 **단위 자원이 여러 개일 때 사용**하는 알고리즘
  - 자원을 요청 받으면, 그 자원을 할당해주고 난 후의 상태를 계산해서 그것이 안전 상태인지 확인한다.
    - 안전 상태가 보장되는 경우에만 자원을 할당한다.
  - 자료구조
    - **available**: 각 자원의 사용 가능량을 표시하는 벡터
      - `available[j] = k` ⇒ *j번째 자원을 k개 사용 가능함*
    - **max**: 각 프로세스의 자원 최대 요구량을 표시하는 2차원 행렬
      - `max[i][j] = k` ⇒ $*P_i$는 $R_j$를 최대 k개까지 요청함*
    - **allocation**: 각 프로세스의 현재 자원 할당량을 표시하는 2차원 행렬
      - `allocation[i][j] = k` ⇒ $*P_i$는 $R_j$를 k개 할당받고 있음*
    - **need**: 각 프로세스의 자원 추가 요구량을 표시하는 2차원 행렬
      - `need[i][j] = k` ⇒ $*P_i$의 작업을 종료하려면 $R_j$가 k개 더 필요함*
  - 동작 원리

    <img width=500 src="https://github.com/user-attachments/assets/88810308-f029-41cc-a9ca-d89c27be3392">

    1. 자원 추가 요구량 구하기
      `need[i] = max[i] - allocation[i]`
    
    2. 상태 검사
      1. 각 프로세스의 수행 여부를 체크하는 벡터 finish 초기화
        `finish[i] = false (i = 1, 2, 3, …, n)`  
      2. 다음 조건을 만족하는 i 값 탐색
        `IF (finish[i] == false && need[i] ≤ available)`
        조건을 만족하는 i 값이 없다면 d번째 단계로 이동
      3. 자원 할당
        `available = available + allocation[i]`
        `finish[i] = true`
      4. 모든 i에 대해 `finish[i] == true`인 경우 안전 상태, 아니면 불안전 상태

    - 결과

      <img width=500 src="https://github.com/user-attachments/assets/90944dea-4325-49a2-b2c4-1d0279638215">

      P2 → P4 → P1 → P3 순서대로 자원을 할당한다면 모든 요청을 충족할 수 있으므로, 안전 상태다.

### 교착 상태 검출 후 회복
- 데드락 발생을 허용하고, 데드락이 발생하면 프로세스를 종료시키거나 자원을 빼앗아 처리하는 방식   
  즉, 프로세스들이 자원을 요청할 때마다 바로 할당하며, 교착 상태 여부를 주기적으로 검사 후 회복하는 방식

- #### 데드락 검출 방법
  - **Wait-for graph 기반 검출**

    <img width=500 src="https://github.com/user-attachments/assets/6b625377-e46f-4d79-b680-0c9ba3eb314c">

    - 자원 할당 그래프에서 모든 자원들을 제거하여, 사이클이 존재하는지 확인하는 방식
   
  -  **타임아웃 기반 검출**
    - 일정 시간 동안 작업이 진행되지 않은 프로세스를 데드락이 발생한 것으로 간주하여 처리하는 방식
    - 타임아웃이 발생할 때까지 작업이 진행되지 않은 모든 프로세스가 데드락이 발생한 것은 아니기 때문에, 엉뚱한 프로세스가 강제 종료될 수 있다.

- #### 데드락 검출 후 회복하는 방법
  - **자원 선점**
    - 데드락이 해결될 때까지 다른 프로세스로부터 자원을 강제로 빼앗아 한 프로세스에 몰아주는 방식
  - **프로세스 강제 종료**
    - 데드락이 걸린 프로세스들을 모두 강제 종료하는 방식
      - 한 방에 데드락을 해결할 수 있지만, 작업 내용을 손실할 가능성이 높아진다.
    - 데드락이 없어질 때까지 한 프로세스씩 강제 종료하는 방식
      - 작업 내용 손실을 최소화할 수 있지만, 데드락이 없어졌는지 여부를 확인하는 과정에서 오버헤드가 발생한다.
     
### 교착 상태 무시
- 데드락이 발생하면 어떤 처리도 하지 않는 방식
- 데드락은 실제로 매우 드물게 발생하므로, 데드락에 대한 처리 자체가 더 큰 오버헤드일 수 있다.
- 시스템에 데드락이 발생한 경우, 시스템이 비정상적으로 동작하는 것을 사용자가 느낀 후 직접 프로세스를 종료하는 방법으로 대처한다.
- 유닉스, 윈도우 등 대부분의 범용 OS가 채택하는 방식이다.
