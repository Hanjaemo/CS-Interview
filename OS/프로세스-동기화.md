## 📌 병행성(동시성) vs 병렬성
<img width=400 src="https://github.com/user-attachments/assets/eb19f9ce-00fb-49a9-bd59-1d2082527b02">

### 병행성(Concurrency)
- **여러 작업이 동시에 실행되는 것처럼 보이는 상태** (논리적인 개념)
- **싱글 코어에서** 다수의 프로세스들을 빠른 속도로 번갈아 가며 실행하기 때문에, 사용자 입장에서는 동시 처리되는 것처럼 보인다.
- 핵심 목표는  **CPU 유휴 시간을 최소화**하고, 이를 통해 **자원 효율성을 극대화**하는 것이다.
- 실제로 작업이 동시에 실행되는 것이 아니라, 시분할 방식으로 이루어지기 때문에 **연산이 많은 작업에서 성능의 한계가 존재**한다.
- 여러 프로세스들이 자원을 공유하기 때문에 **경쟁 상태나 데드락이 발생**할 수 있다.   
  이러한 동기화 문제를 해결하기 위해 뮤텍스, 세마포어 등 다양한 메커니즘을 사용한다.
- 예시
  - 웹 서버는 여러 클라이언트 요청을 동시에 처리하기 위해, **멀티스레딩** 기법을 이용한다.
  - 대기 시간이 긴 작업(I/O, 네트워크 통신 등)을 **비동기**로 처리하여 프로그램의 반응성을 높인다.

### 병렬성(Parallelism)
- **여러 작업이 실제로 동시에 실행되는 것** (물리적인 개념)
- **멀티 코어 또는 멀티 프로세서에서** 다수의 프로세스들을 독립적으로 실행한다.
- 실제로 여러 작업을 동시에 처리할 수 있기 때문에, **연산이 많은 작업에서 큰 성능 향상을 제공**한다.
- 병행성 시스템에 비해 **설계와 구현이 복잡하며, 동기화 비용도 크다.**
- 주로 **대규모 데이터 처리**나 **복잡한 계산 작업**에서 사용된다.

## 📌 프로세스 동기화
- 여러 프로세스가 공유 자원에 동시 접근할 때, 일정한 순서나 규칙에 따라 동작하도록 조율하는 기법
  - **공유 자원**: 여러 프로세스가 공동으로 이용하는 자원(변수, 메모리, 파일 등)
- 주요 동기화 메커니즘에는 뮤텍스, 세마포어, 모니터, 락이 있다.

### 왜 필요할까?
여러 프로세스가 공유 자원(메모리, 파일, 데이터베이스)에 동시 접근하여 읽기/쓰기 작업을 수행할 때, 동기화가 제대로 이루어지지 않으면 경쟁 상태(데이터 불일치), 데드락 등의 문제가 발생할 수 있다.

<img width=500 src="https://github.com/user-attachments/assets/13beffaf-3640-4572-96af-b3ba15b15c91">

예를 들어, 프로세스 동기화가 이루어지지 않은 상태에서 두 프로세스가 동시에 데이터 쓰기 작업을 수행하면, 해당 데이터가 손상될 수 있다.
따라서 프로세스의 실행 순서를 조율하여 데이터 무결성을 보장하기 위해 동기화가 필요하다.

## 📌 임계 구역(Critical Section)
<img width=500 src="https://github.com/user-attachments/assets/d0792f0d-ba6a-403c-87aa-c9210e19e6b2">

- 여러 프로세스의 공유 자원 접근 순서에 따라 실행 결과가 달라지는 코드 영역
- 잘못된 실행으로 인해 임계 구역의 코드를 동시에 실행할 경우 동기화 문제가 발생한다.

### 프로세스의 일반적인 구조
```c
while (true) {
  entry section // 진입 구역
    critical section // 임계 구역
  exit section // 퇴출
    remainder section // 코드의 나머지 구역
}
```

1. **진입 구역(Entry Section)**: 임계 구역에 진입하기 전에 다른 프로세스가 임계 구역을 사용하고 있는지 확인하고, 사용할 수 있는 권한을 얻는 단계
2. **임계 구역(Critical Section)**: 공유 자원에 접근하여 작업을 수행하는 단계
3. **퇴출 구역(Exit Section)**: 임계 구역에서의 작업이 완료된 후, 해당 프로세스가 임계 구역을 떠나며 다른 프로세스가 임계 구역에 진입할 수 있도록 준비하는 단계

### 임계 구역 문제를 해결하기 위한 동기화의 필수 조건
- **상호 배제(Mutual exclusion)**: 한 프로세스가 임계 구역에 진입해 있는 동안, 다른 프로세스는 임계 구역에 진입할 수 없다.
- **진행(Progress)**: 임계 구역에 어떤 프로세스도 진입하지 않았다면, 임계 구역에 진입하려는 프로세스 중 하나는 임계 구역에 진입할 수 있어야 한다.
- **유한 대기(Bounded waiting)**: 특정 프로세스가 임계 구역에 진입하기 위해 대기하는 시간은 유한해야 한다. 이를 통해 기아 상태를 방지할 수 있다.

## 📌 경쟁 상태(Race Condition)
- 여러 프로세스들이 공유 자원에 동시 접근하여, 해당 자원을 서로 사용하기 위해 경쟁하는 상태
- 경쟁 상태로 인해 예기치 않은 동작이나 버그가 발생할 수 있으며, 이로 인해 데이터의 일관성이 깨질 수도 있다.
- 경쟁 상태를 막기 위해서는, 뮤텍스나 세마포어 같은 동기화 메커니즘을 사용하여 공유 자원에 대한 동시 접근을 적절히 제어해야 한다.

### 경쟁 상태가 발생하는 상황
- **인터럽트가 발생하는 경우**   
  - 어떤 프로세스가 커널 모드에서 실행되는 동안 인터럽트가 발생하면, 현재 실행 중이던 프로세스가 중단되고 인터럽트 서비스 루틴(ISR)이 실행된다. ISR 역시 커널 코드이므로, 이 과정에서 커널의 공유 자원에 접근하면 경쟁 상태가 발생할 수 있다.   
  - 해결 방법: 인터럽트 처리 중에 동기화를 적용하거나, 인터럽트 발생 시점에 특정 자원의 접근을 차단하여 문제가 발생하지 않도록 해야 한다.
    
- **문맥 교환이 발생하는 경우**   
  - 프로세스 A가 시스템 콜을 통해 커널 모드로 진입하여 커널의 공유 자원을 처리하는 중에 문맥 교환이 발생하면, 프로세스 B로 CPU 제어권이 넘어간다. 이때 프로세스 B도 동일한 시스템 콜을 통해 동일한 공유 자원에 접근하면 경쟁 상태가 발생할 수 있다.   
  - 해결 방법: 커널 모드에서 실행 중일 때 문맥 교환이 발생하지 않도록 하거나, 커널 모드에서의 공유 자원 접근 시 동기화 메커니즘을 사용하여 경쟁 상태를 방지해야 한다.
 
## 📌 상호 배제(Mutual Exclusion)
- 공유가 불가능한 자원의 동시 사용을 피하기 위해 사용하는 알고리즘
- 병행 시스템에서 단 하나의 프로세스만이 임계 구역에 접근할 수 있도록 하는 것을 의미한다.
- 예를들어, 어떤 프로세스가 순차적으로 데이터를 읽는 작업을 하는 도중에 다른 프로세스가 해당 데이터를 변경해버리면 읽어오는 값이 달라진다. 따라서 상호배제를 통한 동기화 작업을 해줘야한다.

### 상호 배제 구현 방법
- #### Dekker’s algorithm (Peterson’s algorithm)
  ```c
    // entry section
    void enter_section() {
        flag[i] = true; // 프로세스 i의 임계구역 진입 준비 완료
        turn = j; // 프로세스 j에게 임계구역 진입 순번 부여
    
        // 프로세스 j가 임계 구역에 진입하기를 원한다면 j가 먼저 진입하는 것을 보장하고 기다림
        while (flag[j] && turn == j) ; // busy wait!!!
    }

    // exit section
    void exit_section() {
        flag[i] = false; // 임계구역을 벗어나면서 플래그 off
    }
  ```
  - 고전적인 소프트웨어 기반으로 상호 배제를 구현하는 방법
  - 플래그(`flag`)와 순번(`turn`) 변수를 이용하여 오직 하나의 프로세스만이 임계 구역에 진입하도록 조정하는 알고리즘

- #### TestAndSet(TAS) instruction
  ```c
  void enter_section() {
      while (test_and_set(&lock)) ;
  
      // critical section
  
      lock = false;
  
      // remainder section
  }

  boolean test_and_set(boolean *target) {
      boolean temp = *target
      *target = true;
      return temp;
  }
  ```
  - 하드웨어 수준에서 상호 배제를 구현하는 방법
  - TAS(`test_and_set`) 연산은 문맥 교환 없이 원자적(atomic)으로 수행된다.   
    즉, 특정 메모리 위치의 값을 읽고 새로운 값을 설정하는 작업을 한 번에 수행한다.
  - 원자적인 연산을 통해 임계 구역에 대한 접근 권한을 한 프로세스에만 부여할 수 있다.

- #### OS supported SW solution
  - Spinlock
  - Semaphore

- #### Language-Level solution
  - Monitor

## 📌 뮤텍스 락(Mutual Exclusion Lock; Mutex Lock)
```c
do {
    acquire(); // lock이 걸려 있는지 확인하고, 걸려 있지 않다면 임계 구역에 진입하면서 lock 획득

    // critical section

    release(); // 작업을 마무리한 뒤 임계 구역을 벗어나면서 lock 해제

    // remainder section
} while (true);
```
- 여러 프로세스의 공유 자원 동시 접근을 제한하기 위해 lock을 사용하는 동기화 기법
- 오직 하나의 프로세스만이 lock을 획득할 수 있으며, 그 프로세스만이 lock을 해제할 수 있다.
- 잠금 메커니즘 측면에서 spin lock과 동일하지만, 임계 구역 진입 권한을 획득할 때까지 busy waiting 상태에 머무르지 않고 대기 상태에 접어든다.
- lock을 소유하고 있던 프로세스가 임계 구역을 벗어나면, 운영체제 스케줄러에 의해 대기 상태에 있던 프로세스가 wakeup된다.

 ## 📌 세마포어(Semaphore)
- 프로세스 동기화 기법을 간편하게 제공하는 추상 자료형
- 세마포어 `S`는 정수형 값을 가지며, 자원의 개수를 나타낸다.
- 공용 변수 `S`는 `P`와 `V`라는 원자적(atomical) 연산에 의해서만 접근 가능하다.
  - **P 연산(Wait)**: 세마포어 값을 감소시키는 연산
    - 프로세스나 스레드가 자원을 요청할 때, 즉 임계 구역에 들어가기 전에 수행된다.
    - 만약 세마포어 값이 0이라면, 자원 사용이 불가능하므로 대기한다.
    - 네덜란드어 *proberen*에서 따온 `P`로 표기
  - **V 연산(Signal)**: 세마포어 값을 증가시키는 연산
    - 자원의 사용을 마친 후 자원을 해제할 때, 즉 임계 구역에서 나오는 시점에 수행된다.
    - 임계 구역 앞에서 대기하는 프로세스가 있다면 ‘진입 가능’ 신호를 보낸다.
    - 네덜란드어 *verhogen*에서 따온 `V`로 표기

### 구현 방식
- #### Busy wating 방식 (Spin-Lock)
  ```c
  void P(S) {
      while (S <= 0) { // 남은 공유 자원이 없을 경우, 얻을 수 있을 때까지 반복해서 확인
          ; // busy waiting
      }
      S--; // S가 양수인 경우 임계 구역에 진입하면서 공유 자원 1개 획득
  }
    
  void V(S) {
      S++; // 임계 구역을 벗어나면서 공유 자원 반납
  }
  ```  
  - 원하는 자원을 얻을 수 있을 때까지 반복적으로 확인하는 과정에서 CPU 자원이 소비된다. 이로 인해 자원이 낭비된다는 
 
- #### Block and Wake up 방식 (Sleep-Lock)    
  ```java
  void P(S) {
      S--; // 임계 구역에 진입하면서 공유 자원 1개 획득
      if (S < 0) { // 남은 공유 자원이 없을 경우
          block(); // 현재 프로세스를 대기 큐에 저장하면서 대기 상태로 변경
      }
  }
  
  void V(S) {
      S++; // 임계 구역을 벗어나면서 공유 자원 반납
    	if (S <= 0) { // 남은 공유의 개수가 0 이하일 경우
          wakeup(); // 대기 큐에서 프로세스를 꺼내 준비 상태로 변경
      }
  }
  ```
  - `block()`과 `wakeup()` ⇒ 프로세스를 일시 중지 or 재실행시키는 운영체제의 기본적인 시스템 콜
    > 세마포어 `S`의 값이 0보다 크다면, 이는 자원이 남아 있다는 의미이므로 대기 중인 프로세스가 없을 가능성이 크다. 따라서 대기 중인 프로세스를 깨울 필요가 없다.   
    > 반대로 `S`의 값이 0보다 작거나 같다면, 이는 남아 있는 자원이 없다는 의미이므로 대기 중인 프로세스가 있을 가능성이 크다. 따라서 대기 중인 프로세스를 깨워야 한다.

- 임계 구역 길이가 매우 짧은 경우가 아니라면, 일반적으로 Block and Wake up 방식의 성능이 더 좋다.

### 종류
- **이진 세마포어(Binary semaphore)**
  - `S` == 0 또는 1의 값만 가질 수 있는 세마포어
  - 상호 배제를 위한 동기화 기법으로서 뮤텍스 락과 유사하다.
  - 이진 세마포어 값에 따른 상태 구분
    - 1 ⇒ 공유 자원 접근 가능
    - 0 ⇒ 공유 자원 접근 불가능
- **카운팅 세마포어(Counting semaphore)**
  - `S` == 공유 자원의 수를 나타내는 (양의 정수값을 가지는) 세마포어   
    ex) `S`의 값이 3인 경우, 남은 공유 자원의 개수가 3개라는 의미이므로 최대 3개의 프로세스가 동시에 공유 자원에 접근 가능
