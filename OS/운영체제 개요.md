## 📌 운영체제란?
사용자가 하드웨어를 잘 몰라도 원하는 프로그램을 쉽게 사용할 수 있도록 개발된 소프트웨어

### 하드웨어 자원(CPU, 메모리, I/O 장치 등)을 효율적으로 관리
- 여러 프로세스가 한정된 CPU나 메모리 같은 시스템 자원을 공정하고 효율적으로 사용할 수 있도록 적절히 분배
- ex) CPU 스케줄링, 프로세스 동기화, 가상 메모리 등

### 사용자가 컴퓨터 시스템을 편리하게 사용할 수 있는 환경 제공
- GUI(Graphic User Interface), CLI(Command Line Interface) 제공
- **멀티태스킹**을 지원하여, 사용자가 여러 프로그램을 동시에 사용할 수 있는 환경 제공
  
  > 멀티태스킹이란 스케줄링을 통해 여러 작업을 번갈아가며 처리하는 것을 말하며, 사용자에게 다수의 작업이 동시에 처리되는 것처럼 느끼게 해준다.
  
- 사용자가 데이터를 쉽게 저장, 삭제, 검색할 수 있도록 **파일 시스템** 제공

## 📌 운영체제 유형
### 일괄 처리 시스템(batch processing system)
- 일정 기간 동안 **다수의 프로세스를 모아서 한꺼번에 처리**하는 시스템
- 작업이 차례로 하나씩 실행되므로 어떤 작업이 완전히 끝날 때까지 다른 작업은 대기해야 함
- 초기 컴퓨터 시스템에서 사용됨

### 다중 프로그래밍 시스템(multi-programming system)
- 여러 프로세스들을 메모리에 상주시켜 **하나의 CPU로 동시에 처리**하는 시스템
- CPU를 사용하던 어떤 프로세스가 I/O 작업으로 인해 잠시 대기하는 동안, 메모리에 적재된 다른 프로세스에 CPU를 할당함으로써 **시스템 자원의 효율 극대화**

### 다중 처리기 시스템(multi-processor system)
- 단일 컴퓨터에 **여러 CPU를 사용하여 병렬로 처리**하는 시스템
- 하나의 CPU에 문제가 발생해도 다른 CPU로 처리 가능하므로 **안정적**임
- 여러 CPU가 같은 자원을 공유하기 때문에 **경쟁 상태** 발생 가능

  > #### 💭 어떻게 경쟁 상태를 해결할 수 있을까요?
  > 뮤텍스 락이나 세마포어 같은 프로세스 동기화 기법을 통해 해결 가능 (학습 예정)

- 여러 CPU를 사용하기 때문에 **비용과 복잡도 증가**

### 대화형 시스템(interactive system)
- 컴퓨터와 사용자가 **1:1로 대화**하듯 각 프로그램에 대한 입력의 결과를 곧바로 화면에 출력하는 시스템
- 많은 작업을 한 번에 처리하는 일괄처리 시스템에 비해 **응답 속도가 짧음**

### 시분할 시스템(timesharing system)
<img width=500 src="https://github.com/user-attachments/assets/142bf39b-1571-4e07-a2f2-448833391140">

- 다중 프로그래밍 환경에서 스케줄링을 이용해 **하나의 CPU를 일정한 시간 단위로 분할하여 사용**하는 시스템
- **빠른 응답 속도**로 인해 사용자가 혼자 컴퓨터를 사용하는 것처럼 느끼는 효과 제공

## 📌 커널이란?
- 운영체제는 커널과 시스템 프로그램으로 구분됨
  
  > #### 💭 시스템 프로그램이 무엇인가요?
  > 사용자가 커널에게 명령을 내리기 위해 사용되는 프로그램으로, 커널과 사용자 간의 다리 역할 수행   
  > ex) shell

- 운영체제의 핵심부로 사용자가 하드웨어에 접근하고 통신하기 위한 중간 다리 역할 수행
- 사용자가 물리적인 하드웨어 자원에 접근하고 사용할 수 있도록, 실제로는 **하나뿐인 하드웨어 자원을 여러개의 추상화된 객체로 관리**
  - CPU → 태스크(Task)
  - 메모리(memory) → 페이지(page), 세그먼트(segment)
  - 디스크(disk) → 파일(file)
  - 네트워크(network) → 소켓(socket)
- 시스템 자원만 바라볼 뿐, **사용자와 직접적인 상호작용은 하지 않음**

## 📌 이중모드란?
운영체제는 **응용 프로그램이 하드웨어 자원에 직접 접근하는 것을 제한**하기 위해 2가지 모드 제공

### 커널모드
- 운영체제 서비스를 제공받을 수 있는 실행 모드
- 커널 모드로 실행중인 CPU는 모든 하드웨어 자원 접근 명령어 실행 가능
### 유저모드
- 운영체제 서비스를 제공받을 수 없는 실행 모드
- 유저 모드로 실행중인 CPU는 하드웨어 자원 접근 명령어 실행 불가
- 시스템 콜(System Call)을 통해 커널 모드로 전환
- 일반적인 응용 프로그램은 기본적으로 유저 모드로 실행

## 📌 시스템 콜(System Call)
<img width=600 src="https://github.com/user-attachments/assets/bdeef763-54ae-4ca8-8ae3-313d51dffb89">

- 사용자 프로그램이 운영체제의 **커널에게 서비스를 요청**하기 위해 사용하는 인터페이스
- 사용자 프로그램은 하드웨어 자원에 직접 접근할 수 없기 때문에, 시스템 콜을 통해 이러한 작업 수행 가능

### 동작 원리
<img width="329" alt="image" src="https://github.com/user-attachments/assets/58cd169c-4111-4460-b439-cbfd909f582a">

1. 응용 프로그램을 실행하는 도중, 하드웨어 자원에 접근해야 할 때 시스템 콜을 호출하여 커널모드로 전환
2. 커널 영역에 있는 하드웨어 자원 접근 코드를 실행하여 하드웨어 자원에 접근
3. 하드웨어 자원 접근 종료 시 유저모드로 복귀하여 응용 프로그램 이어서 실행

## 📌 폴링 vs 인터럽트
### 폴링(Polling)
- CPU가 자신과 연결된 I/O 장치에서 무슨 일이 있는지를 주기적으로 확인하는 메커니즘
- 주기적으로 상태를 확인하기 때문에 CPU 자원을 비효율적으로 사용
- 폴링 주기 사이에 상태 변화가 발생하면, 그 변화가 실제로 감지되기까지 시간 지연 발생 → 실시간 처리가 필요한 시스템에 적합하지 않음

### 인터럽트(Interrupt)
- 입출력, 프로그램 오류, 하드웨어 고장 등 갑작스러운 이벤트가 발생했을 때 CPU에게 이를 알려주는 메커니즘
- CPU는 필요할 때만 I/O 장치와 통신하고, 남는 시간에는 다른 작업을 수행할 수 있어 폴링 방식에 비해 자원 효율적임
- 이벤트가 발생하면 즉시 처리할 수 있기 때문에 일반적으로 응답 시간이 빠름 → 실시간 처리가 필요한 시스템에 적합
- 인터럽트 처리 과정
  
  <img width=500 src="https://github.com/user-attachments/assets/82152c94-2fd4-47ea-bcc7-2f563377efb1">

  1. I/O 이벤트가 발생하여 인터럽트 소스가 CPU에게 인터럽트 요청 신호 전송
  2. CPU는 실행 단계가 끝난 뒤, 명령어를 인출하기 전에 항상 인터럽트 요청 확인
  3. 인터럽트를 받아들일 수 있는 경우 CPU는 지금까지의 작업의 상태(프로그램 카운터 값, CPU 레지스터 값, 상태 레지스터 값 등)를 스택에 저장
  4. CPU는 인터럽트 벡터를 참조해 인터럽트 서비스 루틴 실행
     - **인터럽트 벡터**: 인터럽트 서비스 루틴을 식별하기 위한 정보
     - **인터럽트 서비스 루틴(인터럽트 핸들러)**: 인터럽트를 처리하기 위해, 발생한 인터럽트를 어떻게 처리하고 작동해야 할지에 대한 정보로 이루어진 프로그램
    
       <img width=500 src="https://github.com/user-attachments/assets/5e4b2305-f763-40dc-8129-44aca9195896">

  5. 인터럽스 서비스 루틴이 종료되면 스택에 있는 작업의 상태 복구 및 실행 재개

## 📌 DMA(Direct Memory Access)란?
- I/O 장치와 메모리 간의 데이터 전송을 CPU의 개입 없이 직접 처리하는 방식
- DMA 컨트롤러가 CPU 대신 I/O 장치와 메모리 사이의 데이터 이동을 담당하기 때문에, CPU는 데이터 전송 작업에 관여하지 않고 다른 작업 수행 가능

### 동작 원리
<img width=600 src="https://github.com/user-attachments/assets/0b955f8e-732f-4f27-b274-4d089d7eb793">

1. CPU는 DMA 컨트롤러에게 I/O 장치 주소와 수행할 연산 등의 정보와 함께 I/O 작업 명령
2. DMA 컨트롤러는 CPU를 거치지 않고 메모리와 직접 상호작용하여 정보를 읽어오고, 장치 컨트롤러에 전송
3. 작업이 종료되면 DMA 컨트롤러는 CPU에게 인터럽트를 걸어 작업이 종료되었음을 알림

### DMA 방식에서 경쟁 상태를 해결하는 방법
- 시스템 버스는 공유 자원이기 때문에 CPU와 DMA 컨트롤러가 동시에 사용 불가 → 경쟁 상태 발생 가능
- DMA 컨트롤러와 I/O 장치 컨트롤러를 **입출력 버스에 연결**하여, 시스템 버스 사용 빈도 감소 및 경쟁 상태 문제 해결

  <img width=400 src="https://github.com/user-attachments/assets/b1d43ecc-4101-4b59-9fee-24499d47ac21">

## 📌 동기식 I/O vs 비동기식 I/O
### 동기식(Synchronous) I/O
<img width=500 src="https://github.com/user-attachments/assets/4a8080dc-a436-4193-ab15-facf7062b190">

- I/O 작업을 요청한 후, 해당 작업이 완료될 때까지 어떤 작업도 수행하지 않고 기다리는 방식
- I/O 작업이 완료되면 대기중인 프로세스는 실행 상태로 돌아와 작업 이어서 수행
- 구현이 간단하고 직관적이며, 디버깅이나 유지보수가 용이함
- I/O 작업 속도가 느릴 경우 심한 자원 낭비 발생 및 성능 저하

### 비동기식(Asynchronous) I/O
<img width=500 src="https://github.com/user-attachments/assets/e30bc8e7-e2d7-4939-8712-137228230e17">

- I/O 작업을 요청한 후, 해당 작업이 완료되기를 기다리지 않고 바로 다른 작업을 이어서 수행하는 방식
- I/O 작업이 완료되면 인터럽트를 통해 CPU에 작업 완료를 알리고 그 결과를 받아옴
- I/O 작업이 완료되기를 기다리지 않기 때문에 CPU 자원 효율적으로 사용 → I/O 작업 속도가 느려도 성능 유지
- 여러 I/O 작업 동시 처리 가능
- 구현이 상대적으로 복잡하며, 유지보수가 어려움
- I/O 작업과 다른 작업들이 동시에 처리되기 때문에 동기화 문제나 경쟁 상태 등의 문제 발생 가능

  > #### 💭 예를 들어 어떤 문제가 발생할 수 있을까요?
  > - 두 개의 프로세스가 동시에 동일한 파일을 읽거나 쓰려고 할 때, 적절한 동기화가 이루어지지 않으면 파일이 손상될 수 있음
  > - 여러 클라이언트가 동시에 DB에서 동일한 데이터를 수정하려고 할 때, 적절한 트랜잭션 관리나 락 메커니즘이 없으면 데이터 손실 또는 무결성 문제 발생 가능
