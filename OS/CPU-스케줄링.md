## 📌 기아 상태(Starvation)
프로세스의 중요도나 상황에 따라 한정된 CPU를 적절하게 이용할 수 있도록, 운영체제는 각 프로세스마다 우선순위를 부여한다.
이때 우선순위가 낮은 프로세스가 계속 밀려 실행이 지연되는 상태를 **기아 상태**(**Starvation**)라고 한다.

### 기아 상태를 어떻게 해결할 수 있을까?
기아 상태는 **Aging 기법**을 이용하여 해결할 수 있다.
Aging 기법이란, **기아 상태에 빠진 프로세스의 우선순위를 점진적으로 높여서 CPU를 할당받을 수 있도록 하는 것**을 말한다.

## 📌 CPU 스케줄링
CPU 스케줄링은 **여러 프로세스가 CPU를 효율적으로 사용할 수 있도록 스케줄을 조정하는 기법**을 말한다.
예를 들어, I/O 바운드 프로세스를 먼저 처리하여 I/O 장치를 끊임없이 동작시키고, 그 다음 CPU 바운드 프로세스에 집중적으로 CPU를 할당할 수 있다.

> ### 💭 I/O 바운드 프로세스와 CPU 바운드 프로세스
> - **I/O 바운드 프로세스**
>   - I/O 작업이 더 많아 CPU 버스트가 짧은 프로세스
>   - 실행 상태보다는 대기 상태에 더 많이 머무름
>   - ex) 비디오 재생, 디스크 백업
> - **CPU 바운드 프로세스**
>   - CPU 작업이 더 많아 CPU 버스트가 긴 프로세스
>   - 대기 상태보다는 실행 상태에 더 많이 머무름
>   - ex) 복잡한 연산, 그래픽 처리

### CPU 스케줄링이 필요한 상황
- 실행 상태에 있던 프로세스가 I/O 인터럽트에 의해 대기 상태로 바뀌는 경우, 자원이 낭비하지 않도록 하기 위함
- 특정 프로세스가 다른 프로세스보다 더 높은 우선순위를 가질 때, 중요한 작업이 신속하게 처리될 수 있도록 하기 위함
- 여러 사용자가 동시에 작업을 수행하는 서버나 클라우드 환경에서, 각 사용자의 요청을 공정하고 효율적으로 처리하기 위함

### 스케줄러의 종류
스케줄러는 **준비 상태에 있는 프로세스들 중 어떤 프로세스에게 CPU를 할당할지 결정하는 운영체제 코드**를 말한다.
이는 크게 비선점형 방식과 선점형 방식으로 나뉜다.

- **비선점형** → FCFS, SJF, HRN
- **선점형** → SRTF, RR
- **혼합** → MLQ, MLFQ

## 📌 비선점형 스케줄링 vs 선점형 스케줄링
### 비선점형(Non-preemptive) 스케줄링
- 하나의 프로세스가 자원을 사용하고 있는 경우, 그 프로세스가 종료되거나 대기 상태에 접어들기 전까지는 다른 프로세스에 자원을 할당할 수 없는 방식
- **문맥 교환 횟수가 감소**하고, 이에 따라 **오버헤드 발생 가능성도 감소**한다.
- 하나의 프로세스가 **자원을 독점**할 수 있기 때문에, **자원 활용률이 감소**한다.

### 선점형(Preemptive) 스케줄링
- 어떤 프로세스가 자원을 사용하고 있더라도, 운영체제가 해당 프로세스로부터 자원을 강제로 빼앗아 다른 중요한 프로세스에게 할당할 수 있는 방식
- 어느 하나의 프로세스도 **자원 독점이 불가능**하므로, **자원 활용률이 증가**한다.
- **문맥 교환 횟수가 증가**하고, 이에 따라 **오버헤드 발생 가능성도 증가**한다.

## 📌 선입선처리(First Come First Served, FCFS)
- **프로세스가 준비 큐에 삽입된 순서대로 CPU를 할당**하는 **비선점형** 스케줄링 기법
- 먼저 온 요청을 우선으로 처리하기 때문에 합리적인 것 같지만, **호위 효과**(**Convoy Effect**)를 일으킨다.   

  예를 들어, CPU 버스트가 긴 프로세스가 CPU 버스트가 짧은 프로세스 여러 개보다 먼저 준비 큐에 삽입된 경우, CPU 버스트가 짧은 다수의 프로세스들이 CPU 버스트가 긴 하나의 프로세스를 기다려야 한다.

  <img width=500 src="https://github.com/user-attachments/assets/f9516b3f-bd55-485a-a0f2-770aeeb98fd1">

  짧은 프로세스들에게 잠깐 동안만 CPU를 할당하면 이 프로세스들이 CPU 버스트를 마친 뒤 I/O 작업을 연이어 수행할 수 있는데, CPU 버스트가 긴 프로세스 하나 때문에 대기시간은 물론 I/O 장치들의 이용률까지도 동반 하락하게 된다.

### 동작 원리
| 프로세스 | 도착 시간 | 작업 시간 |
| --- | --- | --- |
| A | 0 | 30 |
| B | 3 | 18 |
| C | 6 | 9 |

1. 프로세스 A는 0ms에 준비 큐에 도착한 뒤 곧바로 30ms동안 실행된다.
2. 프로세스 B와 C가 각각 3ms, 6ms에 도착하지만, CPU는 이미 A에 할당된 상태라 기다린다.
3. 30ms에 프로세스 A가 종료되면, 다음으로 준비 큐에 들어온 B에게 CPU를 할당한다.
- A 대기 시간 ⇒ 0ms
- B 대기 시간 ⇒ 30 - 3 = 27ms
- C 대기 시간 ⇒ 48 - 6 = 42ms
- 평균 대기 시간 ⇒ (0+27+42)/3 = 23ms

## 📌 최단 작업 우선(Shortest Job First, SJF) 스케줄링
- **CPU 버스트가 가장 짧은 프로세스에게 제일 먼저 CPU를 할당**하는 **비선점형** 스케줄링 기법
- CPU 버스트가 짧은 프로세스를 우선 실행하므로 **호위 효과를 방지**할 수 있다.
- CPU 버스트가 짧은 프로세스가 계속해서 삽입되면, CPU 버스트가 긴 프로세스는 영원히 CPU를 할당받지 못하는 **기아 현상이 발생**할 ****수 있다. ⇒ HRN 스케줄링으로 해결 가능

### 동작 원리
| 프로세스 | 도착 시간 | 작업 시간 |
| --- | --- | --- |
| A | 0 | 30 |
| B | 3 | 18 |
| C | 6 | 9 |

1. 0ms에 프로세스 A가 도착하여 실행된다.
2. 프로세스 B와 C가 각각 3ms, 6ms에 도착하지만, A가 종료될 때까지 기다린다.
3. 30ms에 A의 작업이 종료되면, 준비 큐에 있는 프로세스 중 작업 시간이 가장 짧은 C가 다음으로 실행된다.
- A 대기 시간 ⇒ 0ms
- C 대기 시간 ⇒ 30 - 6 = 24ms
- B 대기 시간 ⇒ 30 + 9 - 3 = 36ms
- 평균 대기 시간 ⇒ (0+27+42)/3 = 23ms

## 📌 최고 응답률 우선(Highest Response Ratio, HRN) 스케줄링
- **SJF 스케줄링에서 발생할 수 있는 기아 현상을 해결**하기 위해 고안한 **비선점형** 스케줄링 기법
- 대기 시간과 작업 시간을 바탕으로 최고 응답률을 계산하여 우선 순위를 결정하는 방식
    
  <img width=300 src="https://github.com/user-attachments/assets/4afbd7e7-1d41-4498-bb96-8ccf0f4fa070">

### 동작 원리
| 프로세스 | 도착 시간 | 작업 시간 |
| --- | --- | --- |
| A | 0 | 30 |
| B | 3 | 18 |
| C | 6 | 9 |
| D | 15 | 11 |

1. 0ms에 A가 도착하여 30ms동안 실행된다.
2. A가 실행되는 동안 준비 큐에 있는 모든 프로세스의 응답률을 계산한다.
    - B ⇒ ((30-3)+18) / 18 = **2.5**
    - C ⇒ ((30-6)+9) / 9 = **3.67**
    - D ⇒ ((30-15)+11) / 11 = **2.45**
3. C의 응답률이 가장 높으므로 다음 실행할 프로세스는 C → B → D 순으로 결정된다.

## 📌 최소 잔여 시간 우선(Shortest Remaining Time First, SRTF) 스케줄링
- **SJF 스케줄링을 선점형으로 구현**한 방식의 스케줄링 기법
- 현재 실행 중인 프로세스의 남은 CPU 버스트 시간보다 더 짧은 CPU 버스트 시간을 가지는 프로세스가 준비 큐에 삽입될 경우, 현재 실행 중인 프로세스로부터 CPU를 빼앗아 새로 삽입된 프로세스에 할당한다.

### 동작 원리
| 프로세스 | 도착 시간 | 작업 시간 |
| --- | --- | --- |
| A | 0 | 30 |
| B | 3 | 18 |
| C | 6 | 9 |

1. 0ms에 A가 도착하여 실행된다.
2. 3ms에 도착한 B의 작업 시간이 A의 남은 작업 시간(27ms)보다 짧으므로, A로부터 B에게 CPU를 넘겨준다.
3. 6ms에 도착한 C의 작업 시간이 B의 남은 작업 시간(15ms)보다 짧으므로, B로부터 C에게 CPU를 넘겨준다.

## 📌 우선순위 스케줄링
- 프로세스들에 우선 순위를 부여하고, **가장 높은 우선 순위를 가진 프로세스부터 실행**하는 스케줄링 기법
    - **만약 우선 순위가 동일한 프로세스가 있다면 FCFS 스케줄링으로 처리**한다.
- **기아 현상**이 발생할 수 있기 때문에 **aging 기법을 사용**한다.

## 📌 라운드 로빈(Round Robin, RR) 스케줄링
- FCFS 스케줄링에 타임 슬라이스가 더해진 **선점형** 스케줄링 기법
    
    > **타임 슬라이스**: 각 프로세스가 CPU를 사용할 수 있는 정해진 시간
    
- 준비 큐에 삽입된 순서대로 **정해진 시간(타임 슬라이스) 동안만 CPU를 사용**한다.
- 정해진 시간이 경과하면 해당 프로세스를 준비 큐의 마지막에 삽입하고, CPU를 다음 프로세스에게 할당한다.
- **타임 슬라이스의 크기가 매우 중요**하다.
    - 타임 슬라이스가 너무 길면 호위 효과 발생 가능
    - 타임 슬라이스가 너무 짧으면 문맥 교환의 오버헤드 증가
 
### 동작 원리
타임 슬라이스 = 10ms

| 프로세스 | 도착 시간 | 작업 시간 |
| --- | --- | --- |
| A | 0 | 30 |
| B | 3 | 18 |
| C | 6 | 9 |

1. 0ms에 A가 도착하여 실행되다가 10ms가 지나면, 다음 프로세스인 B에게 CPU를 할당하고 A를 준비 큐 마지막에 삽입한다.
2. B가 실행되다가 10ms가 지난 시점인 20ms가 되면, C에게 CPU를 할당하고 B를 준비 큐 마지막에 삽입한다.
3. 29ms에 C가 종료되면 A에게 CPU를 다시 할당한다.

## 📌 멀티 레벨 큐(Multi-Level Queue, MLQ) 스케줄링
<img width=500 src="https://github.com/user-attachments/assets/67b01ec5-c397-430d-a3c6-7716c8fc289b">

- **우선순위별로 여러 개의 준비 큐를 사용**하는 스케줄링 기법
- 준비 큐는 I/O 바운드 프로세스를 담기 위한 **전위 큐**와 CPU 바운드 프로세스를 담기 위한 **후위 큐**로 분할된다.
  - **전위 큐**에서는 응답시간을 짧게하기 위해 **RR 스케줄링 기법을 사용**한다.
  - 응답시간이 크게 의미를 갖지 않는 **후위 큐**에서는 **FCFS 스케줄링 기법을 사용**하여 문맥교환 오버헤드를 줄인다.
- 프로세스에 대한 스케줄링 뿐만 아니라 큐 자체에 대한 스케줄링(어느 큐에 먼저 CPU를 할당할 것인지 결정하는 스케줄링)도 필요하다.

### 고정 우선순위 방식
- **큐별로 고정 우선순위를 부여**하여 우선순위에 따른 스케줄링을 하는 방법
- 우선순위가 낮은 큐는 우선순위가 높은 큐가 비어있을 때에만 CPU를 할당한다.
- **큐에 대한 기아 현상이 발생**할 수 있다.

### 타임 슬라이스 방식
- **각 큐에 CPU 시간을 적절한 비율로 할당**한다.
- **큐에 대한 기아 현상을 방지**할 수 있다.
- ex) 전위 큐에는 80%, 후위 큐에는 20%를 할당해서 스케줄링한다.

## 📌 멀티 레벨 피드백 큐(Multi-Level Feedback Queue, MLFQ) 스케줄링
<img width=400 src="https://github.com/user-attachments/assets/7b69a1d6-c37d-44ee-a9fa-99321270e321">

- CPU를 기다리는 프로세스를 여러 큐에 삽입하는 측면에서는 멀티 레벨 큐와 동일하지만, **프로세스가 큐 사이를 이동할 수 있다**는 점이 다르다.
- 프로세스의 큐 사이 이동 가능으로 인해 **기아 현상이 발생**할 수 있기 때문에, **aging 기법을 적용**한다.
  - 우선순위가 낮은 큐에서 오래 대기한 프로세스를 우선순위가 높은 큐로 이동시킨다.
 
### 동작 원리
1. 프로세스가 준비 큐에 도착하면 우선순위가 가장 높은 큐에 삽입된다. CPU 버스트 시간이 짧은 프로세스는 우선순위가 가장 높은 RR 큐에서 빠르게 처리될 수 있다.
2. 8ms만큼의 시간 동안 CPU를 사용하고도 작업을 완료하지 못한 (CPU 버스트 시간이 긴) 프로세스는 하위 RR 큐로 삽입된다.
3. 이후 16ms만큼의 시간을 추가로 사용하고도 작업을 완료하지 못한 프로세스는 CPU 바운드 프로세스로 간주되어 최하위 FCFS 큐로 삽입된다.
